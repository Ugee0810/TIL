🍿 이 글은 24년 10월 2일 서울에서 열린 U/Day Seoul: Industry 행사에 참석한 후 강연을 리뷰한 내용입니다. 개인적인 견해가 추가된 부분이 있으니 정독간에 유의하시기 바랍니다.

U/Day Seoul: Industry는 디지털 트윈을 활용한 혁신적인 사례와 기술을 선보이며 자동차, 제조, 건설 등 다양한 산업 분야에서 Unity를 활용한 경험을 공유하는 행사입니다.

<br/>

# 📂 10:40 - 11:20 | 향상된 웹 경험의 시작: Unity 6와 함께!
Unity 6가 제공하는 새로운 웹 기능과 이를 통한 향상된 사용자 경험에 대해 알아봅니다. Unity 6는 보다 빠르고 안정적인 웹 런타임을 제공하여, 웹 애플리케이션 개발자들에게 최적의 환경을 제공합니다. 특히, 산업용 애플리케이션의 높은 성능과 안정성 요구를 충족시키는 기술적 진보를 소개할 예정입니다. 간단한 데모를 통해 Unity 6가 웹 환경에서 어떻게 향상된 성능을 구현하는지 직접 확인해 보겠습니다.

양진석, Lead, Partner Engineering, Unity

<br/>

# 📚 웹을 위한 애플리케이션 개발
### 📖 웹이 강력한 이유
![image](https://github.com/user-attachments/assets/74a3308f-ea4d-4560-afb9-c9f06ccb6a1d)

📄 막힘 없는 간편한 접근성
- 사용자가 스마트폰으로 QR 코드를 스캔하거나 링크를 클릭하면 즉시 경험에 참여할 수 있음
- 즉각적인 참여가 가능하므로, 복잡한 설치 과정 없이 빠르게 접근할 수 있음

📄 중간 단계를 없앤 간편한 직결
- 웹앱을 통해 크리에이터와 사용자 간에 중간 단계 없이 바로 연결이 가능
- 크리에이터와 사용자가 직접적으로 소통할 수 있어, 마켓플레이스나 중개자가 필요하지 않음
- 이 과정에서 중간 유통에 따른 수수료 부담을 없앨 수 있음

<br/>

### 📖 우리가 해결하려는 문제
![image](https://github.com/user-attachments/assets/64f01157-a94b-4c4e-9216-ecae7a152b2d)

📄 크리에이터가 사용자에게 데스크탑이나 모바일 기기에 앱 설치를 요청하면, 참여율이 급격히 떨어집니다.
- 설치 과정의 번거로움
사용자들이 새로운 앱을 설치하는 데는 여러 단계를 거쳐야 하며, 설치 과정에서 복잡함이나 시간 소모가 발생하면 포기할 가능성이 높습니다.
- 용량 문제
기기에 저장 공간이 부족한 사용자는 앱 설치를 주저할 수 있습니다.
- 보안 우려
일부 사용자는 새로운 앱 설치에 대한 보안 우려를 갖고, 특히 개인 정보를 요구하는 경우 더 큰 저항을 느낍니다.
- 즉각적인 사용성 부족
사용자는 즉각적으로 콘텐츠에 접근하기를 원하며, 앱 설치는 이런 즉각적인 만족을 방해하는 요인으로 작용합니다.
- 기기 호환성 문제
특정 운영 체제나 버전에서만 설치 가능한 경우 참여를 방해할 수 있습니다.

📄 모바일 마켓플레이스는 크리에이터에게 큰 부담입니다.
- 높은 수수료
많은 모바일 마켓플레이스는 크리에이터가 수익을 얻기 위해 일정 비율의 수수료를 부과합니다. 이는 특히 소규모 크리에이터에게는 큰 부담으로 작용할 수 있습니다.
- 정책 제한
각 마켓플레이스는 자체적인 정책과 규정을 가지고 있어, 크리에이터가 원하는 방식으로 콘텐츠나 서비스를 제공하는 데 제한이 따를 수 있습니다.
- 경쟁 과열
수많은 앱과 서비스가 등록되어 있는 마켓플레이스에서 크리에이터가 눈에 띄기 어려워 마케팅 비용도 추가로 부담해야 할 수 있습니다.

<br/>

### 📖 웹에 가장 적합한 앱은 무엇일까요? - 고객 성공 사례
![image](https://github.com/user-attachments/assets/d401f0e4-dfbc-4df2-98de-db3f8672f94e)

📄 마케팅/영업 - NASA의 아르테미스 미션 추적기

- 복잡한 기술 제품이나 프로세스를 사용자에게 고도화된 시뮬레이션으로 제공하여 제품 이해를 도울 수 있음
- 예시로, NASA의 아르테미스 미션 추적기와 같은 고급 기능이 포함된 웹 애플리케이션
- 아르테미스 실시간 궤도 웹사이트는 작년 11월 발사된 아르테미스 I 임무를 위한 실시간 인터랙티브 추적기이다. 웹사이트를 통해 사용자는 아르테미스 I의 미션을 실시간으로 관찰하고 추적할 수 있다. 그 결과, 전 세계의 우주 팬들이 웹 브라우저를 통해 궤도와 착수 지점을 실시간으로 추적 가능하며 복잡한 우주 미션을 웹 기술로 실시간으로 제공함으로써 전 세계 사용자들이 손쉽게 우주 탐험의 현장에 참여할 수 있었음.

📄 온보딩/데모 - 사용자를 앱 다운로드로 이끄는 온보딩 및 데모

- 샘플이나 튜토리얼을 제공한 후, 사용자가 해당 콘텐츠에 몰입하게 되면 앱 다운로드로 전환시키는 방식
- 사용자 경험을 미리 제공하여, 앱 설치에 대한 저항을 줄임

📄 위치 기반 실시간 3D 콘텐츠 - 축구 경기 실시간 3D 경험

- QR 코드를 스캔하거나 이벤트, 리테일, 스포츠 경기와 같은 위치 기반 실시간 3D 콘텐츠에 연결
- 실시간으로 콘텐츠에 접근할 수 있어 사용자 참여를 높임

<br/>

# 📚 WebGL → Unity Web
- WebGL에서 Unity Web으로 이름이 변경되었으며, 웹 런타임에 대한 대규모 투자가 이루어짐
- 성능, 최적화, 플랫폼 지원 측면에서 큰 발전이 있었음

<br/>

### 📖 이름을 왜 변경하나요?
![image](https://github.com/user-attachments/assets/d8e6997f-d722-4da4-a864-bd2bcc033c26)

📄 혼란 감소

- WebGL 기술과 Unity 플랫폼 간의 혼란을 줄이기 위해 이름을 변경
- 기술적으로 WebGL은 렌더링 기술이지만, Unity 플랫폼은 더 포괄적인 개발 플랫폼이기 때문에 이 두 개념 간의 혼동을 방지

📄 미래 대비

- 다양한 렌더링 표준이 공존하는 미래를 대비하여, 이름을 더 포괄적으로 변경
- WebGL뿐만 아니라 WebGPU 같은 차세대 렌더링 기술도 지원, 이를 통해 다양한 기술을 사용해 빌드를 생성할 수 있도록 준비

이 이름 변경은 단순한 기술적 진보뿐만 아니라, Unity 플랫폼의 역할과 기능을 더 명확하게 전달하기 위한 전략적 변화임을 강조합니다.

<br/>

## 📖 Unity Web: 주요 빌드 옵션
![image](https://github.com/user-attachments/assets/101d5416-feef-4bea-8708-274571e14538)

웹에서 Unity 애플리케이션을 실행하기 위한 다양한 빌드 옵션을 제공하며, WebGL과 WebGPU는 차세대 웹 애플리케이션의 성능을 크게 향상시킬 수 있는 기술적 도약을 의미합니다. Facebook Instant Games와 같은 플랫폼과의 연동은 보다 빠르고 간편한 배포 경로를 제공해 게임 개발자들에게 많은 이점을 가져다줍니다.

📄 WebGL 빌드

WebGL 그래픽스 API를 사용해 웹 브라우저에서 어디서든 Unity 애플리케이션을 실행할 수 있는 기능을 제공합니다. WebGL은 웹 기반 그래픽을 처리하는 표준 기술로, Unity 앱을 설치할 필요 없이 웹 브라우저에서 바로 실행 가능합니다.

WebGL은 하드웨어에 구애받지 않고 브라우저에서 게임 및 애플리케이션을 실행할 수 있다는 큰 장점이 있습니다. 성능은 네이티브 애플리케이션보다는 다소 낮을 수 있지만, 웹에서의 접근성 측면에서는 매우 효과적인 선택입니다.

📄 WebGPU 빌드

Unity 6에서는 WebGPU의 얼리 액세스를 제공하며, 최신 WebGPU 그래픽스 API를 사용해 고성능 그래픽 경험을 웹에서도 제공할 수 있습니다. WebGPU는 기존의 WebGL보다 더 높은 성능을 제공하며, 차세대 웹 그래픽스 표준으로 떠오르고 있습니다.

WebGPU는 WebGL의 후속 기술로, 그래픽 및 연산 성능이 크게 향상됩니다. 복잡한 그래픽 렌더링 및 데이터 처리가 필요한 애플리케이션에서 웹에서의 성능 한계를 극복할 수 있는 기술입니다. 특히 게임, AR/VR, 시뮬레이션과 같은 고사양 애플리케이션에서 큰 도약을 가져올 수 있습니다.

📄 인스턴트 게임 빌드 (Facebook Instant Games)

Unity 6.x부터 Facebook Instant Games 빌드를 지원합니다. Facebook과 Messenger 플랫폼에서 인스턴트 게임을 개발, 최적화, 업로드하는 과정을 간소화하여 빠르게 게임을 배포할 수 있게 돕습니다.

Facebook Instant Games는 빠른 게임 배포와 접근성을 제공하는 플랫폼으로, 특히 캐주얼 게임 개발자들에게 적합합니다. Unity의 이 지원을 통해 개발자들은 복잡한 과정 없이 빠르게 게임을 시장에 출시할 수 있어, 모바일 게임 개발 및 배포에 매우 유리한 환경을 제공합니다.

![image](https://github.com/user-attachments/assets/69d7fd9e-90e2-49fc-b8ed-f28ae1ea0929)

이와 같은 기능들은 Unity Web이 보다 복잡하고 고성능의 웹 애플리케이션 개발을 가능하게 하며, 특히 산업용 시뮬레이션, 게임, AI 기반 애플리케이션에서 매우 유용하게 활용될 수 있습니다.

📄 C/C++ 멀티스레딩

Unity 6에서는 C/C++ 코드에서 멀티스레딩을 활성화할 수 있으며, 이를 통해 웹 환경에서 병렬 처리의 성능을 극대화할 수 있습니다. 이것은 Unity 엔진에서 사용하는 플러그인 등의 코드에 해당됩니다. 하지만 C#에서는 WebAssembly의 가비지 컬렉션 제약 때문에 멀티스레딩이 아직 지원되지 않습니다. Unity 측에서 차후 로드맵을 통해 지속적으로 추적한다고 발표했습니다.

멀티스레딩은 고성능 웹 애플리케이션 개발에서 매우 중요한 요소입니다. 특히 물리 연산이나 AI 연산 같은 계산 집약적인 작업에 있어 멀티스레딩을 통해 병목 현상을 줄이고 성능을 크게 향상시킬 수 있습니다. 향후 C#에서도 이 기능이 지원된다면, Unity Web 애플리케이션의 활용도가 더욱 확대될 것입니다.

📄 SIMD (Single Instruction Multiple Data)

SIMD는 CPU에서 동일한 명령을 여러 데이터에 동시에 적용할 수 있는 기능으로, SSE 및 Neon과 같은 기술을 통해 CPU 성능이 크게 향상됩니다.

SIMD는 복잡한 수학 연산을 포함한 그래픽 처리와 물리 연산에서 매우 중요한 역할을 합니다. 이를 통해 연산의 병렬 처리를 보다 효율적으로 수행할 수 있으며, 웹 기반의 Unity 애플리케이션에서 복잡한 계산을 더 빠르게 처리할 수 있습니다. 특히 게임이나 시뮬레이션 애플리케이션에서 CPU 성능 최적화에 큰 기여를 할 것입니다.

📄 4GB 메모리 제한

하드웨어의 메모리를 따라가지 않고 브라우저의 메모리를 따라가며, 이전 WebAssembly에서는 2GB로 메모리가 제한되었지만, Unity 6부터는 4GB로 증가하여 더 복잡한 애플리케이션을 처리할 수 있습니다.

다만 제약사항으로 칩과 브라우저가 64비트여야 하므로 데스크톱에선 큰 문제는 없으나 대부분이 사용중인 AOS, IOS 디바이스 기본 브라우저는 32비트이므로 아직 이 이슈는 잠재적으로 가지고 있습니다.

![image](https://github.com/user-attachments/assets/eb7dc6fa-1c1a-4008-b165-5ffb3c0e36f0)

Unity 6의 WebAssembly 2023 기능은 웹 브라우저에서 실행 가능한 고성능 Unity 애플리케이션을 제작할 수 있는 중요한 도구입니다. IL2CPP와 Emscripten의 조합을 통해 성능 최적화된 코드를 생성하고, 압축 및 Addressables 자산 관리를 통해 최적의 사용자 경험을 제공합니다. 이를 통해 웹에서의 복잡한 Unity 애플리케이션 실행이 더욱 현실화되고 있습니다.

📄 WebAssembly 2023 구조

- C# 코드에서 CPP로의 변환

  C# 코드는 IL2CPP를 통해 C++ 코드로 변환됩니다. 이 과정에서 IL2CPP는 C# 코드를 중간 메타데이터로 변환한 후, C++ 코드로 변환하게 됩니다.

  IL2CPP는 Unity에서 성능을 극대화하기 위한 중요한 기술로, C# 코드를 네이티브 코드로 변환하여 성능을 크게 향상시킵니다. 특히 웹 환경에서는 최적화된 네이티브 코드를 실행함으로써 브라우저에서 높은 성능을 유지할 수 있습니다.

- Emscripten을 통한 WebAssembly 변환 (중요)

  변환된 C++ 코드는 Emscripten 컴파일러를 통해 WebAssembly(.wasm) 바이너리 포맷으로 컴파일됩니다. 이 WebAssembly 파일은 웹 브라우저에서 실행될 수 있는 포맷입니다.

  WebAssembly는 웹에서 거의 네이티브 수준의 성능을 제공할 수 있는 중요한 기술입니다. Unity가 Emscripten을 사용해 WebAssembly로 변환함으로써, 성능 손실 없이 복잡한 Unity 애플리케이션을 브라우저에서 실행할 수 있습니다.

- 빌드 결과물: .data, index.html, loader.js, WebAssembly

  최종적으로 WebAssembly 파일과 필요한 자원(.data), 실행 로직(loader.js), 프레임워크 코드가 생성됩니다. 이를 Gzip 또는 Brotli와 같은 압축 기술로 최적화하여 웹에서 빠르게 로드될 수 있게 합니다.

  Gzip 또는 Brotli로 압축하여 데이터 전송량을 최소화하는 것은 웹에서 중요한 성능 최적화 방법입니다. 특히 대용량 자산을 포함하는 Unity 애플리케이션에서는 전송 속도를 개선하고 로드 시간을 단축하는 데 큰 도움이 됩니다.

- Addressables를 통한 자산 관리

  Addressables는 Unity의 자산 관리 시스템으로, 자산을 필요에 따라 로드하거나 관리하는 기능을 제공합니다. 이는 WebAssembly 환경에서도 활용될 수 있습니다.

  Addressables는 자산을 효율적으로 관리하고 필요할 때만 로드하여 메모리 사용량을 줄일 수 있는 방법입니다. 이를 통해 웹 애플리케이션에서 더 많은 자산을 효율적으로 관리할 수 있으며, 대규모 게임이나 복잡한 시뮬레이션 애플리케이션에 적합합니다.

![image](https://github.com/user-attachments/assets/6b8c4fbd-9693-426c-90bc-7b9b257c690f)

Unity 6의 WebAssembly 2023 기능 중 특히 네이티브 예외 처리와 SIMD 지원은 웹 환경에서도 고성능 애플리케이션을 실행할 수 있는 길을 열어주며, 복잡한 연산과 그래픽 처리가 요구되는 애플리케이션에서 매우 유용할 것입니다.

📄 WebAssembly 네이티브 예외 처리

초기 WebAssembly는 예외 처리를 JavaScript로 처리했지만, 이 방식은 오버헤드가 크고 성능 저하를 초래했습니다. Unity 6의 WebAssembly 2023에서는 네이티브 예외 처리를 도입하여, 렌더링 성능을 개선하고 `.wasm` 코드의 크기를 줄였습니다. 

네이티브 예외 처리의 도입은 WebAssembly에서 성능을 크게 향상시킬 수 있는 중요한 개선 사항입니다. 예외 처리를 네이티브 레벨에서 처리함으로써 JavaScript와의 상호작용을 줄이고, 불필요한 성능 저하를 방지할 수 있습니다. 이는 복잡한 게임 로직이나 웹 애플리케이션에서 예외 처리를 보다 빠르게 할 수 있어 전체적인 애플리케이션 성능에 큰 도움이 됩니다. 결론적으로 WebAssembly의 코드가 줄어든다면 웹 로드 속도를 개선 시키는데 큰 기여를 합니다.

📄 WebAssembly SIMD(Single Instruction Multiple Data) 지원

SIMD 명령어를 통해 WebAssembly는 브라우저에서 렌더링 성능을 향상시킬 수 있습니다. SIMD를 사용하면 복잡한 수학 연산을 병렬로 처리할 수 있어 연산 속도가 크게 개선됩니다. 이 기능은 특히 애니메이션 계산이나 캐릭터 스키닝에서 성능을 크게 향상시킵니다.

SIMD는 다수의 데이터에 동일한 연산을 동시에 적용하는 방식으로, 복잡한 수학 연산이나 그래픽 처리에서 매우 중요한 기술입니다. 이를 통해 애니메이션이나 물리 연산, 캐릭터 스키닝과 같은 작업이 웹 환경에서도 높은 성능으로 실행될 수 있습니다. 이는 특히 고사양 게임이나 복잡한 시뮬레이션 애플리케이션에서 필수적인 기능입니다.

![image](https://github.com/user-attachments/assets/72fe5065-4a58-49b4-9de3-372893bf40b5)

그리고 데이터 처리 성능, 함수 호출 최적화, 그리고 JavaScript와 WebAssembly 간의 상호작용을 개선하는 데 초점을 맞추고 있습니다. 이러한 최적화는 고성능 게임이나 복잡한 웹 애플리케이션에서 실질적인 성능 향상을 기대할 수 있으며, 개발자들이 더 빠르고 효율적으로 작업할 수 있는 환경을 제공합니다.

📄 최적화된 데이터 작업

`memcpy`와 `memset`와 같은 함수 코드 생성을 최적화하여 대량의 데이터를 복사하거나 설정할 때 성능을 개선합니다.

대용량 데이터 처리 시 `memcpy`와 `memset` 함수는 중요한 역할을 합니다. 특히 3D 애플리케이션이나 게임에서 대규모 데이터를 처리할 때, 이러한 최적화는 성능에 큰 영향을 미칩니다. 이를 통해 데이터 복사 및 설정 시 병목 현상을 줄이고, 보다 빠른 실행 속도를 기대할 수 있습니다.

📄 WebAssembly Table 언어 기능

함수 호출 시 코드 생성을 간소화하고, 컴파일 시간을 단축시킵니다. WebAssembly Table은 함수를 배열 형태로 저장하여, 함수 호출 시 효율성을 극대화하는 역할을 합니다.

WebAssembly Table 기능을 통해 함수 호출과 관련된 오버헤드를 줄일 수 있습니다. 복잡한 함수 호출이 빈번한 애플리케이션에서는 성능 최적화가 가능하며, 컴파일 시간 또한 줄일 수 있어 대규모 프로젝트의 개발 속도가 개선됩니다.

📄 BigInt 지원

JavaScript와 WebAssembly 간의 64비트 정수를 손쉽게 주고받을 수 있으며, 마샬링 성능을 향상시키고 코드 크기를 줄이는 데 기여합니다.

BigInt는 JavaScript에서 큰 정수(64비트 이상)를 처리하기 위한 객체입니다. WebAssembly와의 상호작용에서 BigInt 지원은 대규모 숫자 계산이나 정밀도가 중요한 애플리케이션에서 매우 중요합니다. 이를 통해 두 환경 간의 데이터 전송이 더 효율적으로 이루어지며, 코드 크기 감소는 성능 향상과 초기 로딩 시간을 단축시킵니다.

![image](https://github.com/user-attachments/assets/22e1156f-e561-4ecf-b742-e475eb84bba2)

📄 모바일 브라우저 지원

Unity 6부터는 iOS와 Android 기기에서도 웹 빌드를 지원하며, iOS의 Safari 15 이상 및 Android의 Chrome 58 이상에서 Unity 웹 애플리케이션을 실행할 수 있습니다.

모바일 브라우저에서 Unity 애플리케이션을 직접 실행할 수 있게 된 것은 모바일 사용자 경험에 있어서 큰 진전을 의미합니다. 이를 통해 별도의 앱 설치 없이 모바일 환경에서 바로 고성능 애플리케이션을 실행할 수 있어 사용자 접근성이 크게 향상됩니다.

📄 모바일 브라우저에서 직접 실행

모바일 브라우저에서 Unity 애플리케이션을 바로 실행할 수 있어, 앱 설치나 별도의 다운로드 과정 없이 즉각적인 사용이 가능합니다.

이 기능은 앱 설치에 대한 진입 장벽을 줄이고, 즉시성에 중점을 둔 사용자의 요구에 부합합니다. 특히 프로토타입, 게임, 시뮬레이션 등 빠른 테스트나 체험이 필요한 콘텐츠에 매우 유용합니다.

📄 웹뷰를 통한 네이티브 앱 내장

웹뷰를 통해 Unity 웹 애플리케이션을 네이티브 앱 안에 내장할 수 있어, 웹 기반 기능을 네이티브 앱에서 그대로 활용할 수 있습니다.

웹뷰를 사용하면 네이티브 앱과 웹 콘텐츠를 쉽게 통합할 수 있어, 이미 구축된 웹 애플리케이션을 네이티브 앱에 추가로 통합할 때 매우 유용합니다. 이는 개발 비용을 줄이고 여러 플랫폼에서 동일한 경험을 제공하는 데 큰 장점이 있습니다.

📄 PWA(Progressive Web Apps) 지원

Unity 웹 애플리케이션은 PWA 템플릿을 사용해 네이티브 앱처럼 동작할 수 있습니다. PWA는 브라우저를 통해 접근할 수 있지만, 네이티브 앱처럼 설치되고 오프라인에서 작동하는 등의 특징을 가집니다.

PWA는 웹 애플리케이션이 모바일 환경에서 네이티브 앱의 기능을 제공할 수 있게 합니다. 이는 특히 다양한 플랫폼에서 동일한 사용자 경험을 제공할 수 있어 유지보수가 용이하고, 웹 개발자들에게 큰 이점을 제공합니다.

![image](https://github.com/user-attachments/assets/ab34347f-9ce2-4929-9a35-94988cade6ef)

Unity 6의 새로운 Unity Web 기능: WebGPU 지원에 대한 내용을 다루고 있습니다. WebGPU는 차세대 웹 그래픽스 성능을 크게 향상시키는 중요한 기술입니다.

📄 WebGPU: 웹 기반 그래픽스 성능의 미래

WebGPU는 웹에서 고성능 그래픽을 처리할 수 있는 차세대 표준입니다. WebGL에 비해 더 나은 성능과 효율성을 제공하며, GPU의 성능을 극대화하여 더 복잡한 그래픽 작업을 웹에서도 처리할 수 있도록 합니다.

WebGPU는 그래픽 연산에서 CPU와 GPU 간의 상호작용을 최적화하여, 브라우저에서 네이티브 수준의 그래픽 성능을 구현하는 것을 목표로 합니다. 이를 통해 더욱 복잡하고 정교한 3D 그래픽, AR/VR, 시뮬레이션 애플리케이션이 웹 환경에서도 원활하게 실행될 수 있습니다.

📄 최신 API 로우레벨 인터페이스 제공

WebGPU는 로우레벨 인터페이스를 제공하여 개발자가 CPU와 GPU 성능을 극대화할 수 있는 기회를 제공합니다. 이를 통해 다양한 GPU 최적화 작업이 가능해집니다.

로우레벨 인터페이스는 고급 개발자들이 더욱 세밀하게 그래픽 하드웨어를 제어할 수 있도록 하며, 복잡한 연산을 더욱 효율적으로 처리할 수 있게 합니다. 이는 게임 개발뿐만 아니라, 데이터 시각화나 시뮬레이션 등 GPU 성능이 중요한 분야에서도 큰 도움이 될 것입니다.

📄 웹에서도 컴퓨트 셰이더 사용 가능

WebGPU를 사용하면 웹 환경에서도 컴퓨트 셰이더(Compute Shader)를 사용할 수 있습니다. 이를 통해 VFX Graph나 GPU skinning 같은 고성능 그래픽 기능을 웹에서 활용할 수 있게 됩니다.

컴퓨트 셰이더는 대규모 병렬 연산에 매우 유용하며, 복잡한 비주얼 이펙트와 3D 모델의 스키닝을 빠르고 효율적으로 처리할 수 있게 해줍니다. VFX Graph와 같은 그래픽 툴과의 통합을 통해 보다 정교한 그래픽 효과를 구현할 수 있으며, 이를 웹에서도 사용할 수 있다는 점은 매우 큰 혁신입니다.

<br/>

# 📚 모바일 브라우저 지원을 위한 최적화 팁

- Unity 6부터는 Android와 iOS 브라우저를 포함한 웹 어디서나 Unity 앱을 실행할 수 있게 지원
- 모바일에서도 고성능 Unity 애플리케이션을 브라우저 기반으로 실행 가능

![image](https://github.com/user-attachments/assets/648f01b8-934f-4218-aab4-bfa2c638625e)

📄 가장 큰 도전 과제: 초기 로딩 시간

웹 애플리케이션의 즉각적인 참여를 위해서는 로딩 시간을 최소화하는 것이 매우 중요합니다. 사용자들은 긴 로딩 시간을 참지 못하고 이탈할 가능성이 높기 때문에, 초기 로딩 시간을 최적화하는 것이 필수적입니다.

특히 모바일 환경에서는 네트워크 속도가 데스크탑보다 느리기 때문에, 초기 로딩 시간의 중요성은 더욱 큽니다. 사용자가 웹 애플리케이션을 처음 실행할 때 빠른 로딩 속도를 제공하면 이탈률을 줄이고, 사용자 경험을 극대화할 수 있습니다.

📄 핵심 해결책: .wasm 파일과 .data 파일의 크기 감소

Unity Web 빌드에서 두 핵심 파일인 `.wasm` 파일과 `.data` 파일의 크기를 줄이는 것이 초기 로딩 시간을 줄이는 데 가장 효과적입니다. 이 파일들은 애플리케이션 실행에 필요한 코드와 데이터를 포함하고 있어, 이들의 크기가 클수록 로딩 시간이 길어집니다.

`.wasm` 파일과 `.data` 파일의 크기를 줄이기 위한 방법으로는 코드의 최적화, 리소스의 압축, 불필요한 데이터의 제거 등이 있습니다. 또한, 사용자에게 필요한 리소스만 먼저 로드하고 나머지는 비동기적으로 로딩하는 방식도 효과적일 수 있습니다. 이를 통해 초기 로딩 시간을 줄여 사용자의 빠른 접근을 유도할 수 있습니다.

![image](https://github.com/user-attachments/assets/f315ffc5-b119-4e71-96b0-312483830e38)

📄 웹에서는 다른 플랫폼과 다른 압축 표준을 사용

웹 환경에서 사용하는 텍스처 압축 방식은 데스크탑이나 모바일과 다르며, 각 플랫폼에 맞는 최적화가 필요합니다.

웹 환경은 다양한 브라우저와 하드웨어에서 작동하므로, 각각의 플랫폼에 맞춘 텍스처 압축을 적용하는 것이 중요합니다. 이를 통해 다양한 장치에서 최적의 성능을 제공할 수 있습니다.

📄 데스크탑용 Crunched DXT

Crunched DXT는 텍스처를 DXT 형식으로 압축하는 것보다 더 작은 파일 크기를 제공하지만, 로딩 중 추가 압축 해제가 필요합니다.

Crunched DXT는 용량을 줄여 전송 속도를 개선할 수 있지만, 로딩 시 압축을 해제하는 데 시간이 추가적으로 소요됩니다. 이는 용량 최적화와 로딩 시간 간의 균형을 고려해야 할 문제입니다. 고해상도 그래픽이 많은 애플리케이션에서는 이 방법을 통해 큰 성능 개선을 기대할 수 있습니다.

📄 모바일용 ASTC

모바일 환경에서는 ASTC(Adaptive Scalable Texture Compression)를 사용하여 텍스처 압축을 최적화할 수 있습니다. ASTC는 다양한 압축 비율을 제공하여, 성능과 화질 간의 균형을 조정할 수 있습니다.

ASTC는 모바일 디바이스에서 매우 효율적인 압축 방법으로, 다양한 해상도와 품질 설정에 유연하게 대응할 수 있습니다. 특히 고성능 게임이나 그래픽이 중요한 애플리케이션에서 더 적은 리소스로 고품질 텍스처를 제공할 수 있어, 모바일 웹에서 성능 향상에 중요한 역할을 합니다. 웹 또한 이 압축 방식을 추천하고 있습니다.

![image](https://github.com/user-attachments/assets/f54b9eee-f495-404b-92f2-c6a9a4ac9933)

오디오 압축에 대해 다루고 있습니다. 대부분의 사람들은 텍스처 압축에 중점을 두고 오디오 압축은 간과합니다. 그러나 오디오 또한 중요합니다. 이를 적절하게 관리하면 메모리 사용량을 줄이고, 시작 시간을 단축하는 데 중요한 역할을 할 수 있습니다.

📄 Compressed In Memory

오디오는 필요할 때까지 압축 상태로 유지되며, 첫 요청 시 압축이 해제되어 재생됩니다. 이 과정에서 약간의 지연이 발생할 수 있지만, 배경 음악과 같은 메모리 절약이 필요한 상황에서 적합합니다.

메모리 사용이 제한된 모바일 환경에서는 `Compressed In Memory` 방식을 사용하여 메모리 절약 효과를 얻을 수 있습니다. 하지만 처음 오디오를 요청할 때 약간의 재생 지연이 발생할 수 있기 때문에, 배경 음악처럼 즉각적인 반응이 필요하지 않은 경우에 이 방법이 적합합니다. 메모리 절약과 지연 발생 간의 균형을 맞추는 것이 중요합니다.

📄 Decompress On Load

앱 시작 시 오디오 압축을 메모리에서 해제하여, 오디오가 즉시 재생될 수 있습니다. 이 방식은 오디오 재생에 지연이 없어 효과음이나 중요한 사운드에 적합하지만, 메모리 사용량이 증가할 수 있습니다.

이 방식은 즉각적인 오디오 재생이 필요한 경우에 매우 적합합니다. 특히 게임의 효과음이나 알림음처럼 재생 타이밍이 중요한 상황에서는 `Decompress On Load` 방식을 사용하여 지연 없이 오디오를 재생할 수 있습니다. 그러나 메모리 사용량이 늘어날 수 있다는 점을 고려해, 오디오 파일의 크기를 최적화하고 필요하지 않은 경우에는 메모리에서 해제하는 관리가 필요합니다.

오디오 압축 최적화는 메모리 사용량과 오디오 재생 타이밍 간의 균형을 맞추는 데 중요한 역할을 합니다. `Compressed In Memory` 방식은 메모리 절약을 우선으로 하지만 재생 지연이 있을 수 있고, `Decompress On Load` 방식은 즉각적인 재생이 가능하지만 메모리 사용량이 증가할 수 있습니다. 각각의 상황에 맞는 최적의 방식을 선택해 사용하는 것이 중요합니다.

![image](https://github.com/user-attachments/assets/3ce7a220-7028-4fe9-82f3-116aaafda362)

배포 빌드 압축에 대한 내용을 설명하고 있습니다. 애플리케이션의 초기 로딩 시간을 줄이기 위해 압축을 사용하는 방법에 대한 설명으로, GZip과 Brotli 같은 주요 압축 알고리즘을 다루고 있습니다.

📄 GZip

GZip은 가장 쉽게 설정할 수 있는 압축 방식으로, 거의 모든 웹 서버와 웹 브라우저에서 기본적으로 지원됩니다. 추가 설정이 거의 필요 없으며, 비교적 큰 빌드 크기와 짧은 빌드 시간을 제공합니다.

GZip은 가장 널리 사용되는 압축 형식으로, 호환성이 매우 높습니다. 대부분의 환경에서 추가 작업 없이 바로 적용할 수 있는 장점이 있어, 간단한 최적화가 필요한 프로젝트에 적합합니다. 다만, 압축 효율은 Brotli에 비해 낮아 더 큰 파일 크기를 초래할 수 있습니다.

📄 Brotli

Brotli는 GZip에 비해 압축률이 더 높아, 상대적으로 작은 빌드 크기를 제공하지만, 빌드 시간이 길어질 수 있습니다. 지원 가능한 웹 서버에서는 Brotli를 사용하는 것이 권장됩니다.

Brotli는 GZip보다 더 나은 압축률을 제공하여, 특히 대용량 웹 애플리케이션에서 로딩 시간을 줄이는 데 효과적입니다. 그러나 빌드 시간이 길어지는 단점이 있으므로, 빌드 시간이 중요한 상황에서는 GZip을 선택하는 것이 더 나을 수 있습니다. 최적의 성능을 위해서는 사용 중인 웹서버가 Brotli를 지원하는지 확인하는 것이 중요합니다.

결론적으로 개발 과정에서 비교적 빌드 시간이 짧은 GZip 형식으로 개발 및 테스트를 진행하다가 최종 릴리스 때 Brotli 형식으로 압축하여 배포하는 방법을 추천합니다.

![image](https://github.com/user-attachments/assets/cc887218-a774-4a8b-819b-c8275bfb42d5)

빌드와 플레이어 세팅에 대한 내용을 다루고 있습니다. 성능 최적화를 위해 코드와 플레이어 설정을 적절하게 구성하는 것이 중요하며, 특히 WebAssembly 빌드와 관련된 최적화 옵션들이 포함되어 있습니다.

📄 빌드 세팅

- Code Optimization: Disk Size with LTO
    
    LTO(Link Time Optimization)는 컴파일된 코드의 크기를 줄이기 위한 최적화 기법입니다. 디스크 용량을 줄이면서도 성능 손실을 최소화할 수 있습니다.
    
    LTO는 컴파일 시 코드 분석을 더욱 깊이 있게 수행하여, 불필요한 코드를 제거하고 최적화합니다. 특히 모바일 환경에서 파일 크기를 줄이는 데 유리합니다.
    

📄 플레이어 세팅

- Target WebAssembly 2023: 켜기
    
    WebAssembly 2023을 대상으로 하는 최신 최적화를 활성화합니다. 이를 통해 최신 브라우저 및 플랫폼 기능을 사용하여 성능을 극대화하는 데 유리합니다. 따라서 더 나은 성능과 최신 기능을 활용할 수 있습니다.
    
- Enable Native C/C++ Multithreading: 켜기
    
    네이티브 C/C++ 멀티스레딩 기능을 활성화하여 여러 코어에서 병렬 처리를 가능하게 합니다. 따라서 복잡한 계산 작업에서 성능을 향상시키고 이를 통해 CPU 자원을 최대한 활용할 수 있습니다.
    
- .NET API Compatibility: .NET Standard 2.1
    
    .NET API 호환성을 .NET Standard 2.1에 맞춰 설정합니다. 이 표준은 다양한 플랫폼에서의 호환성을 보장합니다.
    
    .NET Standard 2.1은 여러 플랫폼과의 호환성을 높이기 위한 가장 안정적인 표준 중 하나입니다. 이를 사용하면 다양한 환경에서 애플리케이션을 실행할 수 있습니다.
    
- IL2CPP Code Generation: Faster runtime
    
    IL2CPP 코드를 더 빠르게 실행할 수 있도록 설정하여 런타임 성능을 높입니다.
    
    IL2CPP는 C# 코드를 네이티브 C++로 변환하여 성능을 향상시키는 기술로, 게임이나 고성능 애플리케이션에서 매우 유용합니다.
    
- Managed Stripping Level: High(또는 Medium)
    
    사용하지 않는 코드를 제거하는 Stripping Level을 높게 설정하여 빌드 크기를 줄입니다.
    
    Managed Stripping은 코드 크기를 줄이는 동시에 성능 저하 없이 메모리 사용을 최적화할 수 있는 효과적인 방법입니다. Medium 또는 High로 설정하면 최적화 효과가 극대화됩니다.
    
- Optimized Mesh Data: 켜기
    
    최적화된 메쉬 데이터를 활성화하여, 그래픽 리소스의 최적화를 돕습니다.
    
    메쉬 데이터의 최적화는 그래픽 처리 속도를 향상시킬 수 있습니다. 복잡한 3D 애플리케이션에서는 이 옵션을 반드시 활성화하는 것이 좋습니다.
    
- Data Caching: 켜기
    
    데이터 캐싱을 활성화하여 네트워크 응답 시간을 줄입니다.
    
    캐싱은 자주 사용되는 데이터를 메모리에 저장하여, 불필요한 네트워크 요청을 줄이고, 성능을 향상시킵니다. 이를 통해 로딩 시간을 단축할 수 있습니다.
    
- Debug Symbols: 끄기
    
    디버그 심볼을 비활성화하여, 빌드 크기를 줄입니다.
    
    디버그 심볼은 디버깅 과정에서 필요하지만, 배포 시에는 빌드 크기를 증가시키므로 끄는 것이 좋습니다.
    
- Enable Exceptions: None (또는 Explicitly Thrown Exceptions Only)
    
    예외 처리 기능을 제한하여 런타임 성능을 최적화합니다.
    
    예외 처리 기능을 최소화하면 성능을 높이는 데 유리합니다. 특히, 필요하지 않은 예외 처리를 비활성화하면 실행 속도를 개선할 수 있습니다.
    
![image](https://github.com/user-attachments/assets/e914f408-f117-4163-9ee0-840cff86078e)

패키지에 대한 내용을 다룹니다. 웹 애플리케이션으로 전환할 때 패키지의 적합성을 고려하고, 필요 없는 패키지를 제거하거나 더 가벼운 대체 패키지를 사용하는 방법에 대한 최적화 전략을 설명합니다.

웹 환경에서 특히 중요한 점은 불필요한 기능이나 리소스를 최소화하는 것입니다. 이는 로딩 시간과 성능에 직접적인 영향을 미치며, 사용자가 빠르게 애플리케이션에 접근할 수 있도록 돕습니다. Json 처리를 위한 `Newtonsoft` 같은 무거운 패키지는 기능은 많지만, 모든 기능을 사용하지 않는다면 용량을 차지할 뿐이므로 가벼운 대체 패키지로 전환하는 것이 현명한 선택입니다.

이처럼 애플리케이션의 용량을 줄이고 성능을 높이기 위해 패키지를 신중하게 선택하는 것이 모바일 웹 최적화의 핵심입니다.

📄 불필요한 패키지 제거

웹과 프로젝트에서 사용하지 않는 패키지는 성능 최적화를 위해 삭제하는 것이 좋습니다. 특히, 모바일 환경에서는 불필요한 패키지를 제거하여 빌드 크기를 줄이는 것이 중요합니다.

📄 대체 가능한 패키지 사용

더 가벼운 대체 패키지를 고려하여 필요 이상의 무거운 패키지를 사용하는 것을 피해야 합니다. 예를 들어, JSON 파싱 용도로는 `Newtonsoft` 대신 더 가벼운 `Unity JsonUtility`를 사용할 수 있습니다.

Newtonsoft는 다양한 기능을 제공하지만 무겁기 때문에, 성능 최적화가 필요한 상황에서는 간소화된 `JsonUtility`가 더 적합할 수 있습니다.

<img width="1178" alt="image" src="https://github.com/user-attachments/assets/f083064a-5362-474d-8017-8e8213f784df">

첫 번째 씬 필수 에셋 사전 로드에 관한 내용입니다. 웹 애플리케이션에서 첫 번째 씬 로딩 시간을 줄이기 위해 필수 에셋과 어드레서블을 미리 로드하는 방법을 다루고 있습니다.

사전 로딩 전략은 웹 성능 최적화에 있어 매우 중요한 역할을 합니다. 특히 웹 애플리케이션이 초기 로딩 시 큰 데이터를 다루는 경우, HTTP `preload` 태그를 사용해 첫 씬에 필요한 리소스를 미리 불러오면 사용자 경험을 크게 향상시킬 수 있습니다. 로딩 시간이 길어질수록 사용자의 이탈률이 증가할 수 있으므로, 필수 리소스를 미리 로드하여 이러한 문제를 해결할 수 있습니다.

📄 첫 번째 씬에 필요한 에셋 사전 로드

첫 화면에 필요한 에셋과 리소스는 미리 로드하여 로딩 시간을 최적화할 수 있습니다.

📄 HTTP Preload 태그 사용

`index.html` 파일에서 HTTP `preload` 태그를 사용하여 필요한 파일들을 사전 로드함으로써, 사용자가 처음 웹 애플리케이션에 접근할 때 로딩 시간이 단축됩니다. 이 방법은 주요 리소스 파일을 미리 불러오는 역할을 합니다. 주의할 점으로 너무 많은 리소스를 preload할 경우 네트워크 대역폭에 의해 로딩 시간을 단축시키는 효과를 보기 어려울 수 있습니다. 따라서 preload를 사용할 때와 사용하지 않을 때 프로파일링한 결과를 보시는 것을 추천드립니다.

📄 사용 가능한 태그 예시

슬라이드에서는 `Build.data`, `Build.wasm`, `Build.framework.js`, `Build.loader.js` 등의 필수 파일을 사전 로드하는 `preload` 태그의 예시가 포함되어 있습니다.

📄 Addressables 사용 시

만약 Addressables을 사용할 경우, `StreamingAssets` 폴더에서 JSON 파일을 미리 로드할 수 있습니다. 이를 통해 게임이나 애플리케이션이 사용하는 중요한 데이터를 빠르게 사용할 수 있도록 준비할 수 있습니다.

![image](https://github.com/user-attachments/assets/57d2d022-2ce3-4232-a576-95ebf1531f29)

메모리 사용 문제 진단에 관한 내용을 다루고 있습니다. Diagnostics Overlay는 모바일 브라우저 환경에서의 성능을 최적화하는 데 매우 유용한 도구입니다. 이 도구를 통해 실시간으로 메모리 사용량과 성능을 모니터링할 수 있기 때문에, 앱의 초기 로딩 시간, 프레임률(FPS) 저하, 메모리 초과 등과 같은 성능 문제를 빠르게 진단할 수 있습니다. 이러한 실시간 진단 기능은 특히 리소스가 제한된 모바일 환경에서 개발자가 최적화 작업을 효과적으로 수행하는 데 큰 도움이 됩니다.

📄 Diagnostics Overlay 옵션 사용

Unity에서 제공하는 "Show Diagnostics Overlay" 옵션을 활성화하여, 메모리 사용량 및 성능 관련 문제를 실시간으로 시각적으로 진단할 수 있습니다. 이를 통해 개발자는 앱의 성능을 세부적으로 모니터링하고, 특히 메모리 사용 관련 문제를 확인할 수 있습니다.

📄 진단 정보

예시로 표시된 화면에서, 사용된 메모리 양, FPS(초당 프레임), 렌더링 성능 등 다양한 성능 지표를 확인할 수 있습니다. 이러한 정보는 특히 최적화 과정에서 성능 병목 지점을 식별하는 데 도움이 됩니다.

<br/>

# 📚 WebGPU 소개

- Unity 6 프리뷰에서 WebGPU 얼리 액세스를 제공
- 최신 WebGPU 그래픽스 API를 활용한 고성능 그래픽 경험을 웹에서도 제공할 수 있음

<img width="1207" alt="image" src="https://github.com/user-attachments/assets/2a0f083b-0ab1-4bf4-aa97-691305bcd610">

WebGPU 기술에 대한 설명을 다루고 있습니다. WebGPU는 웹 환경에서의 그래픽 처리 성능을 극대화할 수 있는 기술로, 컴퓨터 그래픽스 및 게임 개발에서 중요한 역할을 할 것입니다. 특히 기존의 WebGL보다 더 향상된 성능과 효율성을 제공함으로써 복잡한 3D 그래픽, 시뮬레이션, 그리고 실시간 효과를 웹 브라우저에서 실행할 수 있게 합니다. 이로 인해 향후 웹 기반 게임 및 시각적 경험이 크게 발전할 것으로 기대됩니다.

📄 WebGPU 정의

WebGPU는 최신 GPU 성능을 활용하도록 설계된 WebGL의 후속 기술로, 더 높은 그래픽 처리 성능을 제공하기 위한 웹 기반 GPU 기술입니다.

📄 컴퓨팅 가속

WebGPU는 컴퓨트 쉐이더를 사용해 GPU에서 대규모 병렬 처리를 수행함으로써, VFX(Visual Effects)나 대규모 계산을 GPU에서 더 빠르게 처리할 수 있습니다.

📄 고급 렌더링

WebGPU는 Forward+ 렌더링을 통해 복잡한 3D 장면에서의 조명 및 오브젝트 제약을 해결하고, 더 나은 그래픽 품질을 제공합니다. 예시로 'URP 3D 샘플'에서 볼 수 있는 고퀄리티 장면 구현이 가능합니다.

📄 미래를 위한 설계

WebGPU는 현재 기술을 기반으로 하고 있지만, 향후 발전 가능성이 높은 기술로, 추가적인 기능과 성능 개선을 제공할 수 있는 기회를 제공합니다.

![image](https://github.com/user-attachments/assets/28439c01-8118-4d10-ac13-c2f47b7cd3cb)

WebGPU 데모에 관한 내용입니다. 이 데모들은 WebGPU 기술을 실무에서 어떻게 활용할 수 있는지를 시각적으로 보여주며, 고급 그래픽 처리가 필요한 프로젝트에서 GPU 성능을 극대화할 수 있는 가능성을 제시합니다.

📄 Unity Discussions

Unity 포럼에서 WebGPU 백엔드에 관한 초기 액세스 정보와 토론을 제공합니다. 링크를 통해 최신 정보를 얻을 수 있습니다. GPU를 활용한 스키닝 기술을 보여주며, 다수의 3D 캐릭터에 대한 실시간 렌더링을 확인할 수 있습니다.

→ [Unity 포럼 링크](https://discussions.unity.com/t/early-access-to-the-new-webgpu-backend-in-unity-2023-3/933493)

📄 Keijiro 웹사이트

Unity 애드버킷인 Keijiro의 웹사이트에서 WebGPU 데모를 확인할 수 있습니다. 여기서는 GPU 스키닝 및 VFX 그래픽 관련 데모를 볼 수 있습니다. VFX(Visual Effects) 그래픽을 WebGPU를 통해 렌더링하는 예시로, 고성능 그래픽 연산이 어떻게 이루어지는지 볼 수 있습니다.

→ [Keijiro WebGPU 테스트 링크](https://www.keijiro.tokyo/WebGPU-Test/)

![image](https://github.com/user-attachments/assets/78a81888-f3ed-4b0c-b3a3-54e764d587a1)

이 슬라이드는 각 운영체제 및 플랫폼에서 WebGPU를 지원하는 주요 브라우저에 대한 정보를 제공합니다. 특히, 일부 브라우저와 플랫폼에서는 실험적 지원이거나 플래그 설정이 필요한 경우가 있습니다. WebGPU는 최신 GPU 성능을 최대한 활용할 수 있도록 설계된 기술로, 다양한 환경에서 브라우저의 GPU 활용성을 높이는 데 중요한 역할을 합니다.

📄 지원 브라우저

- Windows: Chrome, Microsoft Edge
- Android 12+: Chrome
- macOS: Chrome, Safari Technology Preview
- iOS/iPadOS 18: Safari (플래그 설정 필요)
- Linux: Chrome (플래그 설정을 통한 실험적 지원)
- Firefox: 지원이 개발 중










